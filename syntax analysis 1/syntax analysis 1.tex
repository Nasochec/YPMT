% !TeX encoding = windows-1251
\documentclass[fullscreen=true,russian,compress,%
hyperref={unicode,bookmarks=false}]{presentation}
\inputencoding{cp1251} % Кодировка вашего файла 
% Внимание! Опция russian не совместима с \tableofcontents
\usepackage[russian]{babel} % Эту строку можно удалить
\usepackage{paratype} % Выбираем шрифт
\usepackage{appendixnumberbeamer} 

\usepackage{tikz} 
\usepackage{fancyvrb}%для Verbatim
% Определяем длины частей нижнего колонтитула: автор, название, число слайдов
\makefootline{.35}{.55}{.1} % Сумма длин = 1

\usepackage{tikz} % Для создания рисунков с помощью tikz
\usepackage{listings} % Для листингов программ
\setbeamerfont{footline}{size=\fontsize{7}{7}\selectfont}

\graphicspath{ {./pictures/} }

\begin{document}
	
	\newtheorem{Metric}{Метрика}
	\newtheorem{weight}{Распределение весов}
	% Если потребуется, переводим названия блоков с английского:
	\deftranslation[to=Russian]{Theorem}{Теорема}
	\deftranslation[to=Russian]{Example}{Пример}
	%\deftranslation[to=Russian]{Metric}{Метрика}
	
	% Данные титульного слайда
	\title[Синтаксический анализ]{Синтаксический анализ}
	\author{Гладков Артемий Николаевич}
%	\institute{Научный руководитель: к. ф.-м. н., доцент, А.\,В.~Смирнов}
	\date{09.10.2024}
	
	% Создаем титульный слайд
	\begin{frame}
		\titlepage
	\end{frame}
	
	% \tableofcontents не работает при включенной опции russian пакета babel
	%\begin{frame}{Содержание}\tableofcontents\end{frame}
	
	\begin{frame}{Задача синтаксического анализа}
		\begin{itemize}
			\item Требуется установить, имеет ли строка лексем \textbf{структуру}, заданную синтаксисом языка, и зафиксировать эту структуру. 
			
			\item Снова надо решать задачу разбора: дана строка лексем, и надо определить, выводима ли она в грамматике, определяющей синтаксис языка. 
			
			\item Для задания синтаксиса языка используют КС-грамматики. 
		\end{itemize}
	\end{frame}

	\begin{frame}{Как вести разбор?}
		\begin{itemize}
		\item Существуют методы анализа, применимые ко всему классу КС-грамматик и имеющие сложность $O(n^3)$ для разбора строк длины $n$ (алгоритм Кока-Янгера-Касами) либо сложность $O(n^2)$ (алгоритм Эрли).
		
		\item Использование таких алгоритмов оправдано только в том случае, если для языка не существует более простой КС-грамматики.
		
		\item Существуют методы, применимые к разным подклассам КС-грамматик, работающие за $O(n)$. Один из таких методов мы и рассмотрим.
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Метод рекурсивного спуска}
		$G = (\{S, A, B\}, \{a, b, c, \bot\}, S, P)$\\
		\begin{columns}
			\begin{column}{0.3\paperwidth}
				\begin{math}
					P:
					\begin{array}{l}
					S \rightarrow AB\bot\\
					A \rightarrow a \mid cA\\
					B \rightarrow bA
					\end{array}
				\end{math}\\
				$caba\bot \in L(G)?$
			\end{column}
			\begin{column}{0.6\paperwidth}
				\begin{tikzpicture}[main/.style = {draw, circle}] 
					\node[main] (S) {$S$};
					\visible<2->{\node[main] (A1) [below = 1cm] [left = 0.2cm]  {$A$}; 
					\node[main] (B) [below = 1cm] [right = 0.2cm] {$B$}; }
					\node[main] (c) [below = 3cm] [left = 1cm] {$c$}; 
					\node[main] (a1) [below = 3cm] [left = 0.2cm] {$a$}; 
					\node[main] (b) [below = 3cm] [right=0.2cm] {$b$}; 
					\node[main] (a2) [below = 3cm] [right = 1cm] {$a$}; 
					\node[main] (bot) [below = 3cm] [right = 3cm] {$\bot$}; 
					
					\visible<2->{
						\draw (S) -- (A1);
						\draw (S) -- (B);
						\draw (S) -- (bot);
					}
					\visible<3->{
						\node[main] (A2) [below = 2cm] [left = 0.2cm]  {$A$}; 
						\draw (A1) -- (A2);
						\draw (A1) -- (c);
					}
					\visible<4->{\draw (A2) -- (a1);}
					\visible<5->{
						\node[main] (A3) [below = 2cm] [right = 0.6cm]  {$A$}; 
						\draw (B) -- (A3);
						\draw (B) -- (b);
					}
					\visible<6->{\draw (A3) -- (a2);}
				\end{tikzpicture} \\
			
			\end{column}
		\end{columns}
		Цепочка выводов:
		$$S \visible<2->{\Rightarrow AB\bot} \visible<3->{\Rightarrow cAB\bot} \visible<4->{\Rightarrow caB\bot} \visible<5->{\Rightarrow cabA\bot} \visible<6->{\Rightarrow caba\bot}$$
	\end{frame}
	
	\begin{frame}[fragile]{Реализация алгоритма рекурсивного спуска}

		
		\begin{columns}
			\begin{column}{0.45\paperwidth}
			{\scriptsize
\begin{Verbatim}[tabsize=3]
#include <stdio.h>
// Символ конца строки
#define EOF '&' 
// Текцщий исмвол
int c;
// Ситаем строку из файла
FILE* fp; 
void A();
void B();
//функция обработки ошибок
void ERROR(); 
void S() {
	A(); B();
	if (c != EOF) ERROR();
}
void A() {
	if (c == 'a')
		c = fgetc(fp);
	else if (c == 'c') {
		c = fgetc(fp);
		A();
	}
	else ERROR();
}
\end{Verbatim}
			}
			\end{column}
			\begin{column}{0.45\paperwidth}
				{\scriptsize
\begin{Verbatim}[tabsize=3]
void B() {
	if (c == 'b'){
		c = fgetc(fp);
		A();
	}
	else ERROR();
}
void ERROR() {
	printf("ERROR!!!");
	throw "error";
}
int main() {
	fp = fopen("data", "r");
	c = fgetc(fp);
	S();
	printf("SUCCESS!!!"); 
	return 0;
}
\end{Verbatim}
				}
			\end{column}
		\end{columns}
		
	\end{frame}
	
	\begin{frame}{Синтаксис М-языка}
		\begin{columns}
			\begin{column}{0.4\paperwidth}
				\\
			$P \rightarrow \textbf{program}\: D_1\: B \bot$ \\
			$D_1 \rightarrow \textbf{var}\: D \: \{;D\} $\\
			$D \rightarrow I \{;I\}: [\textbf{int}|\textbf{bool}] $\\
			$B \rightarrow \textbf{begin}\: S \{;S\}\: \textbf{end} $\\
			\mbox{$ S \rightarrow I := E \mid \textbf{if}\: E \: \textbf{then}\: S \: \textbf{else} \: S \mid \textbf{while}\: E \: \textbf{do}\: S \mid B\mid  \textbf{read}(I)\mid \textbf{write}(E) $}\\
			
			$E \rightarrow E_1 \mid E_1 [=|<|>|!=] E_1$\\
			$E_1 \rightarrow T \{[+|-|\textbf{or}] T\}$\\
			$T \rightarrow F \{[*|/|\textbf{and}]F\}$\\
			$F \rightarrow I \mid N \mid L \mid \textbf{not} \: F \mid (E) $\\
			$L \rightarrow \textbf{true}\:\mid\:\textbf{false} $\\
			\visible<-1>{
			$I \rightarrow C\:\mid IC\mid IR $\\
			$N \rightarrow R\mid NR$\\
			\mbox{$C \rightarrow a\mid b\mid \hdots \mid z\mid A \mid B \mid \hdots \mid Z$ }
			$R \rightarrow 0\mid 1\mid \hdots \mid 9$
			}
				
			\end{column}
			\begin{column}{0.5\paperwidth}
				\vspace{2cm}\\
				
				\visible<2->{В данном случае I (Идентификаторы) и N (числовые константы) рассматриваются как целые лексемы. То же самое касается и ключевых слов и разделителей вроде $:=$ и $!=$.}\\			
			\end{column}
		\end{columns}
		
	\end{frame}
	
	\begin{frame}{Применимость метода рекурсивного спуска}
		
		Метод применим в том случае, если каждое правило грамматики имеет вид:
		
		\begin{itemize}
			\item либо $A\rightarrow \alpha,$ где $\alpha\in(N\cup T)^*$ и это единственное правило вывода для этого нетерминала.
			\item либо $A\rightarrow a_1\alpha_1\mid\hdots\mid a_n\alpha_n,$ где $a_i\in T, \forall i=\overline{1,n}$ и $a_i \neq a_j$, при $i\neq j$.
		\end{itemize}
		
		Описанные условия являются достаточными, но не необходимыми.
		\pause
		\begin{block}{Замечание}
			То есть, аналогично идее лексического разбора, мы будем прочитывать по \textbf{одномой} лексеме и, в зависимости от её значения, выбирать следующий шаг.
		\end{block}
	\end{frame}
	
	\begin{frame}[fragile]{Применимость метода рекурсивного спуска}
		\begin{itemize}
			\item Часто в языках программирования встречаются конструкции вида $L\rightarrow a\mid a,L$ или сокращённо $L\rightarrow a\{,\:a\}$.
			
			\item Пример таких конструкций: параметры функций, арифметические выражения и так далее.
			
			\item При попытке вывести строку $a,a,a,a$ можно остановиться на вариантах $a$ либо $a,a$ либо $a,a,a$.
			
			\item В таких случаях будем выбирать самую длинную подстроку, чтобы сделать разбор детерминированным.
		\end{itemize}
		
		Реализация L:
		{\small
\begin{Verbatim}[tabsize=3]
void L() { 
	if (c != 'a') ERROR();
	while ((c = fgetc(fp)) == ',')
		if ((c = fgetc(fp)) != 'a') 
			ERROR();
}
\end{Verbatim}
}

	\end{frame}
	
	\begin{frame}[fragile]{Применимость метода рекурсивного спуска}
		
		Также могут встречаться эпсилон-продукции. Например: $A\rightarrow aA\mid \epsilon$.\\
		В синтаксисе языка это будет означать опциональность конструкции.\\
		Реализация будет выглядеть так:
		{\small
\begin{Verbatim}[tabsize=3]
void A(void) {
	if (c == ‘a’) {
		c = fgetc(fp); 
		A();
	}
}
\end{Verbatim}
		}
		\pause
		\begin{block}{Замечание}
			Для корректной работы необходимо, чтобы в грамматике не имелось продукций вида $B\rightarrow \alpha Aa\beta, \forall\alpha.\beta\in(N\cup T)*, B\in N.$ То есть, чтобы после нетерминала $A$ не мог стоять символ $a$, иначе возникает неоднозначность.
		\end{block}
	\end{frame}
	
	\begin{frame}[fragile]{Пример реализации распознавателя M-языка}
		\begin{columns}
			\begin{column}{0.5\paperheight}
				$D_1\rightarrow \textbf{var}\: D \{; \: D\}$
				{\small
					\begin{Verbatim}[tabsize=3]
void D1()
{
	if (eq("var")) 
		curr_lex = getlex();
	else 
		ERROR();
	D();
	while (eq(";")) {
		curr_lex = getlex(); 
		D();
	}
}
					\end{Verbatim}
				}
			\end{column}
			\begin{column}{0.5\paperheight}
				$D\rightarrow I \{,\: I\}: [\textbf{int}\mid\textbf{bool}]$
				{\scriptsize
					\begin{Verbatim}[tabsize=2]
void D (){
	if (!id()) ERROR();
	else {
		curr_lex = getlex();
		while (eq(",")){
			curr_lex = getlex();
			if (!id()) ERROR();
			else curr_lex = getlex();
		}
		if (!eq(":")) ERROR();
		else {
			curr_lex = getlex();
			if (eq ("int") 
				|| eq ("bool")) 
				curr_lex = getlex();
			else 
				ERROR();
		}
	}
}					
					\end{Verbatim}
				}
			\end{column}
		\end{columns}
	
	\end{frame}

	\begin{frame}{Что дальше?}
		\begin{itemize}
			\item Посмотреть видео с моей реализацией синтаксического анализатора: <ссылка>.
			\visible<2->{\item Сделать лабораторную работу №2 по синтаксическому анализу.}
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Лабораторная работа №2}
		\begin{itemize}
			\item Разбивка по вариантам и сами варианты будут выложены в курсе в moodle. И туда же нужно прикрепить решения.
			\item Что требуется? --- Реализовать синтаксический анализатор.
			\item Дедлайн: 4 недели.
			\item Когда сдавать? --- На следующих парах или online(назначим созвон на один из вечеров).
		\end{itemize}
	\end{frame}
	
	\begin{frame}{Будущие лекции}
		\begin{itemize}
			\item Занятие 3: первая половина пары -- проверка контекстных условий.
			\item Занятие 4: первая половина пары -- генерация внутренних представлений.
			\item Занятие 5: первая половина пары -- исполнение кода.
			\item Занятие 6: приём Лабораторных. Или конец материала, если что-то не успеем.
		\end{itemize}
	\end{frame}
%	\appendix
%	
%	\begin{frame}{Распределение вероятностей в смешанных стратегиях}
%		
%	\end{frame}
	
\end{document}

